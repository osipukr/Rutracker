@inject ITorrentService TorrentService
@inject IFileService FileService
@inject ICommentService CommentService
@inject IJSRuntime JsRuntime

@page "/torrents/{id:int}"

<ArrowBack Link="@Constants.Path.Torrents" />

<Page Action="@LoadAction" Errors="@Errors">
    <TorrentDetails Torrent="@TorrentDetailsModel"
                    ShowActions="@IsCurrentUserTorrent"
                    OnUpdate="@UpdateAsync"
                    OnDelete="@DeleteAsync"
                    OnImageChange="@ChangeImageAsync"
                    OnImageFileChange="@ChangeImageFileAsync"
                    OnImageDelete="@DeleteImageAsync" />

    <MatAccordion class="mt-3">
        <MatExpansionPanel>
            <MatExpansionPanelSummary class="no-select">
                <MatExpansionPanelSubHeader style="flex-basis: auto;">
                    Files (@Files.Count)
                </MatExpansionPanelSubHeader>
            </MatExpansionPanelSummary>
            <MatExpansionPanelDetails>
                <FileList Items="@Files"
                          ShowActions="@IsCurrentUserTorrent"
                          TorrentId="@Id"
                          OnCreate="@FileCreateAsync"
                          OnDelete="@FileDeleteAsync"
                          OnDownload="@FileDownloadAsync" />
            </MatExpansionPanelDetails>
        </MatExpansionPanel>

        @if (CommentPagination != null)
        {
            <MatExpansionPanel>
                <MatExpansionPanelSummary class="no-select">
                    <MatExpansionPanelSubHeader style="flex-basis: auto;">
                        Comments (@CommentPagination.TotalItems)
                    </MatExpansionPanelSubHeader>
                </MatExpansionPanelSummary>
                <MatExpansionPanelDetails>
                    <ListItemsHeader Title="Total comments" TotalItems="@CommentPagination.TotalItems" />

                    <CommentList Items="@Comments"
                                 OnCreate="@CommentCreateAsync"
                                 OnUpdate="@CommentUpdateAsync"
                                 OnDelete="@CommentDeleteAsync"
                                 OnLike="@CommentLikeAsync" />

                    @if (CommentPagination.TotalPages > 1)
                    {
                        <Pagination Page="@Page"
                                    PageSize="@PageSize"
                                    TotalPages="@CommentPagination.TotalPages"
                                    TotalItems="@CommentPagination.TotalItems"
                                    OnPageChange="@PageChanged" />
                    }
                </MatExpansionPanelDetails>
            </MatExpansionPanel>
        }
    </MatAccordion>
</Page>

@code
{
    [CascadingParameter] public Task<AuthenticationState> AuthenticationStateTask { get; set; }
    [Parameter] public int Id { get; set; }

    private TorrentDetailsViewModel TorrentDetailsModel { get; set; }
    private PaginationResult<CommentViewModel> CommentPagination { get; set; }
    private List<FileViewModel> Files { get; set; } = new List<FileViewModel>();
    private List<CommentViewModel> Comments { get; set; } = new List<CommentViewModel>();

    private int Page { get; set; } = 1;
    private int PageSize => PageSettings.CommentsPerPageCount;
    private bool IsCurrentUserTorrent { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync(async () => TorrentDetailsModel = await TorrentService.FindAsync(Id));

        if (LoadAction == ActionTypes.Succeeded)
        {
            await FilesAsync();
            await CommentsAsync();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        var state = await AuthenticationStateTask;

        IsCurrentUserTorrent = state.IsUserAuthenticated() && state.GetUserId() == TorrentDetailsModel.User.Id;
    }

    private async Task FilesAsync() => await ActionAsync(async () => Files = (await FileService.ListAsync(Id)).ToList());

    private async Task CommentsAsync() => await ActionAsync(async () =>
    {
        CommentPagination = await CommentService.ListAsync(Page, PageSize, Id);
        Comments = CommentPagination.Items.ToList();
    });

    private async Task PageChanged(int page)
    {
        Page = page;

        await CommentsAsync();
    }

    private async Task UpdateAsync(TorrentUpdateViewModel model) => await ActionAsync(async () =>
    {
        if (TorrentDetailsModel.Name == model.Name &&
            TorrentDetailsModel.Description == model.Description &&
            TorrentDetailsModel.Content == model.Content)
        {
            return;
        }

        TorrentDetailsModel = await TorrentService.UpdateAsync(Id, model);

        MatToaster.Add("Torrent updated successfully.", MatToastType.Success);
    });

    private async Task DeleteAsync() => await ActionAsync(async () =>
    {
        await TorrentService.DeleteAsync(Id);

        NavigationManager.NavigateTo(Constants.Path.Torrents);
    }, successMessage: "Torrent successfully deleted.");

    private async Task ChangeImageAsync(ChangeTorrentImageViewModel model) => await ActionAsync(async () =>
    {
        TorrentDetailsModel.ImageUrl = await TorrentService.ChangeImageAsync(Id, model);
    }, successMessage: "Image successfully changed.");

    private async Task ChangeImageFileAsync(string imageUrl) => await ActionAsync(async () =>
    {
        TorrentDetailsModel.ImageUrl = imageUrl;
        await Task.CompletedTask;
    }, successMessage: "Image successfully changed.");

    private async Task DeleteImageAsync() => await ActionAsync(async () =>
    {
        await TorrentService.DeleteImageAsync(Id);

        TorrentDetailsModel.ImageUrl = null;
    }, successMessage: "Image successfully deleted.");

    private async Task FileCreateAsync(IEnumerable<FileViewModel> model) => await ActionAsync(async () =>
    {
        Files.InsertRange(0, model);
        await Task.CompletedTask;
    }, successMessage: $"{model.Count()} files were added.");

    private async Task FileDeleteAsync(FileViewModel model) => await ActionAsync(async () =>
    {
        await FileService.DeleteAsync(model.Id);

        Files.Remove(model);
    }, successMessage: "File deleted successfully.");

    private async Task FileDownloadAsync(int id) => await ActionAsync(async () =>
    {
        var url = await FileService.DownloadAsync(id);

        await JsRuntime.InvokeAsync<object>("openInNewTab", url);
    });

    private async Task CommentCreateAsync(CommentCreateViewModel comment) => await ActionAsync(async () =>
    {
        comment.TorrentId = TorrentDetailsModel.Id;

        var result = await CommentService.AddAsync(comment);

        Comments.Insert(0, result);
    }, successMessage: "Comment created successfully.");

    private async Task CommentUpdateAsync(CommentViewModel comment, CommentUpdateViewModel model) => await ActionAsync(async () =>
    {
        if (comment.Text == model.Text)
        {
            return;
        }

        var result = await CommentService.UpdateAsync(comment.Id, model);
        var index = Comments.FindIndex(x => x.Id == comment.Id);

        Comments[index] = result;

        MatToaster.Add("Comment updated successfully.", MatToastType.Success);
    });

    private async Task CommentDeleteAsync(int id) => await ActionAsync(async () =>
    {
        await CommentService.DeleteAsync(id);

        var index = Comments.FindIndex(x => x.Id == id);

        Comments.RemoveAt(index);
    }, successMessage: "Comment deleted successfully.");

    private async Task CommentLikeAsync(int id) => await ActionAsync(async () =>
    {
        var result = await CommentService.LikeCommentAsync(id);
        var index = Comments.FindIndex(x => x.Id == id);

        Comments[index] = result;
    });
}