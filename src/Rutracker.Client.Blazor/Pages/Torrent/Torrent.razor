@inject ITorrentService TorrentService
@inject ICommentService CommentService

@page "/torrents/{id:int}"

@if (Result == ServiceResult.Failed)
{
    <Alert Type="danger">@Errors</Alert>

    <LoadingBackground ShowLoader="false">
        <span>Error loading torrent information.</span>
    </LoadingBackground>
}
else if (TorrentDetailsModel == null)
{
    <LoadingBackground>
        <span>Loading page model, please wait...</span>
    </LoadingBackground>
}
else
{
    <div class="mat-layout-grid px-0 pb-5">
        <div class="mat-layout-grid-inner">
            <div class="mat-layout-grid-cell">
                <MatIconButton Link="@Constants.Path.Torrents" Icon="@MatIconNames.Arrow_back" />
            </div>
        </div>
    </div>

    <TorrentDetails Torrent="@TorrentDetailsModel" />

    <CommentList Items="@Comments"
                 OnCreate="@CommentCreateAsync"
                 OnEdit="@CommentUpdateAsync"
                 OnDelete="@CommentDeleteAsync"
                 OnLike="@CommentLikeAsync" />
}

@code
{
    [Parameter] public int Id { get; set; }

    private TorrentDetailsViewModel TorrentDetailsModel { get; set; }
    private List<CommentViewModel> Comments { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync(LoadTorrentAsync);
        await LoadAsync(LoadCommentsAsync);
    }

    private async Task LoadTorrentAsync() => TorrentDetailsModel = await TorrentService.FindAsync(Id);
    private async Task LoadCommentsAsync() => Comments = (await CommentService.ListAsync(TorrentDetailsModel.Id)).ToList();

    private async Task CommentCreateAsync(CommentCreateViewModel comment)
    {
        try
        {
            comment.TorrentId = TorrentDetailsModel.Id;

            var result = await CommentService.AddAsync(comment);

            MatToaster.Add("Comment created successfully.", MatToastType.Success);

            Comments.Add(result);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            MatToaster.Add(ex.Message, MatToastType.Warning);
        }
    }

    private async Task CommentUpdateAsync(CommentViewModel comment, CommentUpdateViewModel model)
    {
        try
        {
            var result = await CommentService.UpdateAsync(comment.Id, model);

            MatToaster.Add("Comment updated successfully.", MatToastType.Success);

            var index = Comments.FindIndex(x => x.Id == comment.Id);

            Comments[index] = result;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            MatToaster.Add(ex.Message, MatToastType.Warning);
        }
    }

    private async Task CommentDeleteAsync(int id)
    {
        try
        {
            await CommentService.DeleteAsync(id);

            MatToaster.Add("Comment deleted successfully.", MatToastType.Success);

            var index = Comments.FindIndex(x => x.Id == id);

            Comments.RemoveAt(index);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            MatToaster.Add(ex.Message, MatToastType.Warning);
        }
    }

    private async Task CommentLikeAsync(int id)
    {
        try
        {
            var comment = await CommentService.LikeCommentAsync(id);
            var index = Comments.FindIndex(x => x.Id == id);

            Comments[index] = comment;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            MatToaster.Add(ex.Message, MatToastType.Warning);
        }
    }
}